from collections import Counter
from datetime import datetime
from logging import getLogger
from typing import Any, Dict, List, Union

from django.utils.translation import gettext_lazy as _

from octopoes.models import Reference
from octopoes.models.ooi.dns.zone import Hostname
from octopoes.models.ooi.findings import Finding, KATFindingType, RiskLevelSeverity
from octopoes.models.ooi.network import IPAddressV4, IPAddressV6
from reports.report_types.definitions import Report

logger = getLogger(__name__)


class VulnerabilityReport(Report):
    id = "vulnerability-report"
    name = _("Vulnerability Report")
    description: str = _("Vulnerabilities found are grouped for each system.")
    plugins = {
        "required": ["dns-records", "nmap-ports", "nmap", "nmap-udp", "website-software"],
        "optional": ["shodan"],
    }
    input_ooi_types = {Hostname, IPAddressV4, IPAddressV6}
    template_path = "vulnerability_report/report.html"

    def get_finding_valid_time_history(self, reference: str) -> List[datetime]:
        transaction_record = self.octopoes_api_connector.get_history(reference=reference)
        valid_time_history = [transaction.valid_time for transaction in transaction_record]
        return valid_time_history

    def get_findings(self, input_ooi: str, valid_time: datetime) -> Dict[str, Dict[str, List[Union[str, Finding]]]]:
        reference = Reference.from_str(input_ooi)

        aggregated_findings = []
        finding_types = []
        findings_data = {}

        if reference.class_type == Hostname:
            ips = self.octopoes_api_connector.query(
                "Hostname.<hostname[is ResolvedHostname].address", valid_time, reference
            )
        else:
            ips = [self.octopoes_api_connector.get(reference)]

        for ip in ips:
            findings_ip_port = self.octopoes_api_connector.query(
                "IPAddress.<address[is IPPort].<ooi[is Finding]", valid_time, ip.reference
            )

            findings_software = self.octopoes_api_connector.query(
                "IPAddress.<address [is ResolvedHostname]"
                ".hostname.<netloc [is HostnameHTTPURL]>.<ooi [is SoftwareInstance].<ooi [is Finding]",
                valid_time,
                ip.reference,
            )

            findings = findings_ip_port + findings_software

            for finding in findings:
                finding_type = self.octopoes_api_connector.query(
                    "Finding.finding_type", valid_time, Reference.from_str(finding)
                )[0]
                if finding_type.reference.class_type != KATFindingType:
                    finding_types.append(finding_type)
                    aggregated_findings.append(finding)

            findings_data[ip.primary_key] = {
                "finding_types": finding_types,
                "findings": aggregated_findings,
            }

        return findings_data

    def generate_data(self, input_ooi: str, valid_time: datetime) -> Dict[str, Dict[str, Any]]:
        data = {}
        vulnerabilities = {}
        summary = {}
        critical = RiskLevelSeverity.CRITICAL.value

        first_seen = "-"
        last_seen = "-"
        sources = "-"

        findings = self.get_findings(input_ooi, valid_time)

        for ip, findings_data in findings.items():
            total_criticals = 0
            total_findings = 0
            finding_types_ids = [finding_type.id for finding_type in findings_data["finding_types"]]
            occurrences = Counter(finding_types_ids)
            total_findings += sum(occurrences.values())
            terms = list(occurrences)
            recommendations = []

            # remove duplicate findings and finding types
            finding_types = list(set(findings_data["finding_types"]))
            findings = list(set(findings_data["findings"]))

            for finding_type in finding_types:
                filtered_findings = {}

                for finding in findings:
                    if finding.finding_type.tokenized.id == finding_type.id:
                        time_history = self.get_finding_valid_time_history(finding.primary_key)

                        if time_history:
                            first_seen = time_history[0]

                        origins = self.octopoes_api_connector.list_origins(result=finding.ooi, valid_time=valid_time)
                        sources = ", ".join([origin.method for origin in origins])

                        evidence = origins[0].task_id if origins else "-"

                        filtered_findings[finding.primary_key] = {
                            _("Source"): sources,
                            _("First seen"): first_seen,
                            _("Last seen"): last_seen,
                            _("Evidence"): evidence,
                        }

                        vulnerabilities[finding_type.id] = {
                            "cvss": {
                                "class": str(finding_type.risk_severity.value).lower(),
                                "risk_level": str(finding_type.risk_severity.value).title()
                                + " "
                                + str(finding_type.risk_score),
                            },
                            "occurrences": occurrences[finding_type.id],
                            "description": finding_type.description or "-",
                            "advice": finding_type.recommendation or "-",
                            "findings": filtered_findings,
                        }

                        if finding_type.risk_severity.value == critical:
                            total_criticals += 1

                        if finding_type.recommendation:
                            recommendations.append(finding_type.recommendation)
            summary = {
                "total_findings": total_findings,
                "total_criticals": total_criticals,
                "terms": terms,
                "recommendations": recommendations,
            }

            data[ip] = {"vulnerabilities": vulnerabilities, "summary": summary}

        return data
