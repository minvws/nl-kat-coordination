from collections import Counter
from datetime import datetime
from logging import getLogger
from typing import Any, Dict, List, Union

from django.utils.translation import gettext_lazy as _

from octopoes.models import Reference
from octopoes.models.exception import ObjectNotFoundException
from octopoes.models.ooi.dns.zone import Hostname
from octopoes.models.ooi.findings import Finding, KATFindingType, RiskLevelSeverity
from octopoes.models.ooi.network import IPAddressV4, IPAddressV6
from reports.report_types.definitions import Report

logger = getLogger(__name__)


class VulnerabilityReport(Report):
    id = "vulnerability-report"
    name = _("Vulnerability Report")
    description: str = _("Vulnerabilities found are grouped for each system.")
    plugins = {
        "required": ["dns-records", "nmap", "website-software"],
        "optional": ["nmap-udp", "nmap-ports", "shodan"],
    }
    input_ooi_types = {Hostname, IPAddressV4, IPAddressV6}
    template_path = "vulnerability_report/report.html"

    def get_finding_valid_time_history(self, reference: str) -> List[datetime]:
        transaction_record = self.octopoes_api_connector.get_history(reference=reference)
        valid_time_history = [transaction.valid_time for transaction in transaction_record]
        return valid_time_history

    def get_findings(self, input_ooi: str, valid_time: datetime) -> Dict[str, Dict[str, List[Union[str, Finding]]]]:
        aggregated_findings = []
        finding_types = []
        findings_data = {}

        try:
            ooi = self.octopoes_api_connector.get(Reference.from_str(input_ooi), valid_time)
        except ObjectNotFoundException as e:
            logger.error("No data found for OOI '%s' on date %s.", str(e), str(valid_time))
            raise ObjectNotFoundException(e)

        if ooi.reference.class_type == Hostname:
            ips = self.octopoes_api_connector.query(
                "Hostname.<hostname[is ResolvedHostname].address", valid_time, ooi.reference
            )
        else:
            ips = [ooi]

        for ip in ips:
            findings_ip_port = self.octopoes_api_connector.query(
                "IPAddress.<address[is IPPort].<ooi[is Finding]", valid_time, ip.reference
            )

            findings_software = self.octopoes_api_connector.query(
                "IPAddress.<address [is ResolvedHostname]"
                ".hostname.<netloc [is HostnameHTTPURL]>.<ooi [is SoftwareInstance].<ooi [is Finding]",
                valid_time,
                ip.reference,
            )

            findings = findings_ip_port + findings_software

            for finding in findings:
                finding_type = self.octopoes_api_connector.query(
                    "Finding.finding_type", valid_time, Reference.from_str(finding)
                )[0]
                if finding_type.reference.class_type != KATFindingType:
                    finding_types.append(finding_type)
                    aggregated_findings.append(finding)

            findings_data[ip.primary_key] = {
                "finding_types": finding_types,
                "findings": aggregated_findings,
            }

        return findings_data

    def generate_data(self, input_ooi: str, valid_time: datetime) -> Dict[str, Dict[str, Any]]:
        data = {}
        critical = RiskLevelSeverity.CRITICAL.value

        findings = self.get_findings(input_ooi, valid_time)

        for ip, findings_data in findings.items():
            summary = {}
            vulnerabilities = {}
            total_criticals = 0
            finding_types_ids = [finding_type.id for finding_type in findings_data["finding_types"]]
            occurrences = Counter(finding_types_ids)
            total_findings = sum(occurrences.values())
            terms = list(occurrences)
            recommendations = []

            # remove duplicate findings and finding types
            finding_types = list(set(findings_data["finding_types"]))
            findings = list(set(findings_data["findings"]))

            for finding_type in finding_types:
                filtered_findings = {}

                for finding in findings:
                    if finding.finding_type.tokenized.id == finding_type.id:
                        time_history = self.get_finding_valid_time_history(finding.primary_key)

                        if time_history:
                            first_seen = time_history[0]
                        else:
                            first_seen = "-"

                        origins = self.octopoes_api_connector.list_origins(result=finding.ooi, valid_time=valid_time)
                        sources = ", ".join([origin.method for origin in origins])

                        evidence = origins[0].task_id if origins else "-"

                        filtered_findings[finding.primary_key] = {
                            str(_("Source")): sources,
                            str(_("First seen")): first_seen,
                            str(_("Last seen")): "-",
                            str(_("Evidence")): evidence,
                        }

                vulnerabilities[finding_type.id] = {
                    "cvss": {
                        "class": str(finding_type.risk_severity.value).lower(),
                        "score": finding_type.risk_score,
                        "risk_level": " ".join(
                            [str(finding_type.risk_severity.value).title(), str(finding_type.risk_score)]
                        ),
                    },
                    "occurrences": occurrences[finding_type.id],
                    "description": finding_type.description or "-",
                    "advice": finding_type.recommendation or "-",
                    "findings": filtered_findings,
                }

                if finding_type.risk_severity.value == critical:
                    total_criticals += 1

                if finding_type.recommendation:
                    recommendations.append(finding_type.recommendation)

            summary = {
                "total_findings": total_findings,
                "total_criticals": total_criticals,
                "terms": terms,
                "recommendations": recommendations,
            }

            data[ip] = {"vulnerabilities": vulnerabilities, "summary": summary}

        return data
