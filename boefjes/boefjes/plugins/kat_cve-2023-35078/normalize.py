from typing import Iterable, Union

from boefjes.job_models import NormalizerMeta
from octopoes.models import OOI, Reference
from octopoes.models.ooi.findings import CVEFindingType, Finding
from octopoes.models.ooi.software import Software, SoftwareInstance
from packaging import version

PATCHED_VERSIONS = ["11.10.0.2", "11.9.1.1", "11.8.1.1"]


def jsversion(html_content):
    telltale = b"/mifs/scripts/auth.js?"
    telltalepos = html_content.find(telltale)
    if telltalepos == -1:
        return False
    versionend = html_content.find(b'"', telltalepos)
    versionstring = html_content[telltalepos + len(telltale) : versionend].decode()
    if not versionstring:
        return False
    return version.parse(" ".join(strip_vsp_and_build(versionstring)))


def cssversion(html_content):
    telltale = b"/mifs/css/windowsAllAuth.css?"
    telltalepos = html_content.find(telltale)
    if telltalepos == -1:
        return False
    versionend = html_content.find(b'"', telltalepos)
    versionstring = html_content[telltalepos + len(telltale) : versionend].decode()
    if not versionstring:
        return False
    return version.parse(" ".join(strip_vsp_and_build(versionstring)))


def strip_vsp_and_build(url):
    url_parts = url.split()
    for part in url_parts:
        if str(part).lower() == "vsp":
            continue
        if part.lower() == "build":
            break
        yield part


def check_for_versions(patched_versions, detected_versions):
    for detected_version in detected_versions:
        if detected_version in patched_versions:
            return False
        return any(detected_version < patched_version for patched_version in patched_versions)


def run(normalizer_meta: NormalizerMeta, raw: Union[bytes, str]) -> Iterable[OOI]:
    ooi = Reference.from_str(normalizer_meta.raw_data.boefje_meta.input_ooi)

    detected_versions = (jsversion(raw), cssversion(raw))
    if not any(detected_versions):
        return

    software = Software(name="Ivanti EPMM", version=str(detected_versions[0]))
    software_instance = SoftwareInstance(ooi=ooi, software=software.reference)
    yield software
    yield software_instance
    broken = check_for_versions(
        list(version.parse(patched_version) for patched_version in PATCHED_VERSIONS), detected_versions
    )
    if broken:
        ft = CVEFindingType(id="CVE-2023-35078")
        f = Finding(
            finding_type=ft.reference,
            ooi=software_instance.reference,
            description="Software is most likely vulnerable to CVE-2023-35078",
        )
        yield ft
        yield f
