# Generated by Django 3.2.14 on 2022-07-12 22:03

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
from django.db import migrations, models
from django.utils.functional import cached_property

from django.db.migrations.exceptions import InconsistentMigrationHistory
from django.db.migrations.loader import MigrationLoader
from django.db.migrations.operations.base import Operation
from django.db.migrations.recorder import MigrationRecorder
from django.db.migrations.state import ProjectState, StateApps

import account.models


# We have to moneypatch Django to make this migration work when upgrading an
# installation that used the standard User model. The problem is that when
# changing the user model the migrations depending on User and which already are
# applied will start to depend on this migration, but this one is not yet
# applied. We can ignore this because in the case of upgrade we just use the
# already migrated auth_user table.
def check_consistent_history(self, connection):
    """
    Raise InconsistentMigrationHistory if any applied migrations have
    unapplied dependencies.
    """
    recorder = MigrationRecorder(connection)
    applied = recorder.applied_migrations()
    for migration in applied:
        # If the migration is unknown, skip it.
        if migration not in self.graph.nodes:
            continue
        for parent in self.graph.node_map[migration].parents:
            if parent not in applied:
                # Skip unapplied squashed migrations that have all of their
                # `replaces` applied.
                if parent in self.replacements:
                    if all(m in applied for m in self.replacements[parent].replaces):
                        continue
                parent_migration = self.get_migration(parent[0], parent[1])
                if hasattr(parent_migration.operations[0], "inconsistent_allowed"):
                    continue
                raise InconsistentMigrationHistory(
                    "Migration {}.{} is applied before its dependency "
                    "{}.{} on database '{}'.".format(
                        migration[0],
                        migration[1],
                        parent[0],
                        parent[1],
                        connection.alias,
                    )
                )


MigrationLoader.check_consistent_history = check_consistent_history
ProjectState.apps = cached_property(
    lambda self: StateApps(self.real_apps, self.models, ignore_swappable=True)
)
# Normally this is done when created the class and cached_property requires this
ProjectState.apps.__set_name__(ProjectState, "apps")


def set_full_name(apps, schema_editor):
    KATUser = apps.get_model("account", "KATUser")
    for user in KATUser.objects.all():
        user.full_name = f"{user.first_name} {user.last_name}".strip()
        user.save()


class SwitchToCustomUserModel(Operation):
    """
    Switches Django default user model to an identical custom user model.
    """

    reduces_to_sql = True
    reversible = False
    # This is an attribute introduced so that we can check it in check_consistent_history
    inconsistent_allowed = True

    create_user_model_operation = migrations.CreateModel(
        name="User",
        fields=[
            ("id", models.AutoField(primary_key=True, verbose_name="ID")),
            ("password", models.CharField(max_length=128, verbose_name="password")),
            (
                "last_login",
                models.DateTimeField(blank=True, null=True, verbose_name="last login"),
            ),
            (
                "is_superuser",
                models.BooleanField(
                    default=False,
                    help_text="Designates that this user has all permissions without explicitly assigning them.",
                    verbose_name="superuser status",
                ),
            ),
            (
                "username",
                models.CharField(
                    error_messages={
                        "unique": "A user with that username already exists."
                    },
                    help_text="Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.",
                    max_length=150,
                    unique=True,
                    validators=[
                        django.contrib.auth.validators.UnicodeUsernameValidator()
                    ],
                    verbose_name="username",
                ),
            ),
            (
                "first_name",
                models.CharField(blank=True, max_length=150, verbose_name="first name"),
            ),
            (
                "last_name",
                models.CharField(blank=True, max_length=150, verbose_name="last name"),
            ),
            (
                "email",
                models.EmailField(
                    blank=True, max_length=254, verbose_name="email address"
                ),
            ),
            (
                "is_staff",
                models.BooleanField(
                    default=False,
                    help_text="Designates whether the user can log into this admin site.",
                    verbose_name="staff status",
                ),
            ),
            (
                "is_active",
                models.BooleanField(
                    default=True,
                    help_text="Designates whether this user should be treated as active. "
                    "Unselect this instead of deleting accounts.",
                    verbose_name="active",
                ),
            ),
            (
                "date_joined",
                models.DateTimeField(
                    default=django.utils.timezone.now, verbose_name="date joined"
                ),
            ),
            (
                "groups",
                models.ManyToManyField(
                    blank=True,
                    help_text="The groups this user belongs to. "
                    "A user will get all permissions granted to each of their groups.",
                    related_name="user_set",
                    related_query_name="user",
                    to="auth.Group",
                    verbose_name="groups",
                ),
            ),
            (
                "user_permissions",
                models.ManyToManyField(
                    blank=True,
                    help_text="Specific permissions for this user.",
                    related_name="user_set",
                    related_query_name="user",
                    to="auth.Permission",
                    verbose_name="user permissions",
                ),
            ),
        ],
        options={
            "db_table": "auth_user",
        },
        managers=[
            ("objects", django.contrib.auth.models.UserManager()),
        ],
    )

    def __init__(self):
        # Operations are usually instantiated with arguments in migration
        # files. Store the values of them on self for later use.
        pass

    def state_forwards(self, app_label, state):
        # The Operation should take the 'state' parameter (an instance of
        # django.db.migrations.state.ProjectState) and mutate it to match
        # any schema changes that have occurred.
        self.create_user_model_operation.state_forwards(app_label, state)

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        if "auth_user" not in schema_editor.connection.introspection.table_names():
            # The table doesn't exist, so we aren't upgrading, create the table
            to_state = from_state.clone()
            self.create_user_model_operation.state_forwards(app_label, to_state)
            self.create_user_model_operation.database_forwards(
                app_label, schema_editor, from_state, to_state
            )

    def describe(self):
        # This is used to describe what the operation does in console output.
        return "Switching to custom user model"


def fix_names(apps, schema_editor):
    """Fix names when upgrading"""
    # The index and constraint names aren't renamed when upgrading, so we do it
    # here manually to make sure the databases that have been upgraded will be
    # identical to newly created databases
    with schema_editor.connection.cursor() as cursor:
        cursor.execute(
            "select conname from pg_constraint where conname = 'auth_user_groups_katuser_id_76ed1ca4_fk_auth_user_id'"
        )
        if not len(cursor.fetchall()):
            # Not upraded so we don't have to fix up the constraint names
            return

    schema_editor.execute(
        "ALTER INDEX auth_user_groups_group_id_97559544 RENAME TO account_katuser_groups_group_id_458b8cb6"
    )
    schema_editor.execute(
        "ALTER INDEX auth_user_groups_user_id_6a12ed8b RENAME TO account_katuser_groups_katuser_id_f4516588"
    )
    schema_editor.execute(
        """ALTER INDEX public.auth_user_user_permissions_permission_id_1fbb5f2c
        RENAME TO account_katuser_user_permissions_permission_id_7a0ee5f4
        """
    )
    schema_editor.execute(
        """ALTER INDEX public.auth_user_user_permissions_user_id_a95ead1b
        RENAME TO account_katuser_user_permissions_katuser_id_b66fdc16
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.account_katuser_groups
        RENAME CONSTRAINT auth_user_groups_user_id_group_id_94350c0c_uniq
        TO account_katuser_groups_katuser_id_group_id_1cb4bafd_uniq
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.account_katuser_groups
        RENAME CONSTRAINT auth_user_groups_group_id_97559544_fk_auth_group_id
        TO account_katuser_groups_group_id_458b8cb6_fk_auth_group_id
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.account_katuser_groups
        RENAME CONSTRAINT auth_user_groups_katuser_id_76ed1ca4_fk_auth_user_id
        TO account_katuser_grou_katuser_id_f4516588_fk_account_k
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.account_katuser_user_permissions
        RENAME CONSTRAINT auth_user_user_permissions_user_id_permission_id_14a6b632_uniq
        TO account_katuser_user_per_katuser_id_permission_id_10f2db9d_uniq
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.account_katuser_user_permissions
        RENAME CONSTRAINT auth_user_user_permi_permission_id_1fbb5f2c_fk_auth_perm
        TO account_katuser_user_permission_id_7a0ee5f4_fk_auth_perm
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.account_katuser_user_permissions
        RENAME CONSTRAINT auth_user_user_permissions_katuser_id_a19a8c50_fk_auth_user_id
        TO account_katuser_user_katuser_id_b66fdc16_fk_account_k
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.django_admin_log
        RENAME CONSTRAINT django_admin_log_user_id_c564eba6_fk_auth_user_id
        TO django_admin_log_user_id_c564eba6_fk_account_katuser_id
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.otp_static_staticdevice
        RENAME CONSTRAINT otp_static_staticdevice_user_id_7f9cff2b_fk_auth_user_id
        TO otp_static_staticdevice_user_id_7f9cff2b_fk_account_katuser_id
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.otp_totp_totpdevice
        RENAME CONSTRAINT otp_totp_totpdevice_user_id_0fb18292_fk_auth_user_id
        TO otp_totp_totpdevice_user_id_0fb18292_fk_account_katuser_id
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.password_history_userpasswordhistoryconfig
        RENAME CONSTRAINT password_history_use_user_id_bc5676f2_fk_auth_user
        TO password_history_use_user_id_bc5676f2_fk_account_k
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.tools_indemnification
        RENAME CONSTRAINT tools_indemnification_user_id_2e9bb970_fk_auth_user_id
        TO tools_indemnification_user_id_2e9bb970_fk_account_katuser_id
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.tools_organizationmember
        RENAME CONSTRAINT tools_organizationmember_user_id_c135c874_fk_auth_user_id
        TO tools_organizationmember_user_id_c135c874_fk_account_katuser_id
        """
    )
    schema_editor.execute(
        """ALTER TABLE public.two_factor_phonedevice
        RENAME CONSTRAINT two_factor_phonedevice_user_id_54718003_fk_auth_user_id
        TO two_factor_phonedevice_user_id_54718003_fk_account_katuser_id
        """
    )


def fix_contenttypes_and_permissions(apps, schema_editor):
    ContentType = apps.get_model("contenttypes", "ContentType")
    Permission = apps.get_model("auth", "Permission")
    try:
        ct = ContentType.objects.get(app_label="auth", model="user")
    except ContentType.DoesNotExist:
        pass
    else:
        ct.app_label = "account"
        ct.model = "katuser"
        ct.save()
    try:
        perm = Permission.objects.get(codename="add_user")
    except Permission.DoesNotExist:
        pass
    else:
        perm.codename = "add_katuser"
        perm.name = "Can add kat user"
        perm.save()
    try:
        perm = Permission.objects.get(codename="change_user")
    except Permission.DoesNotExist:
        pass
    else:
        perm.codename = "change_katuser"
        perm.name = "Can change kat user"
        perm.save()
    try:
        perm = Permission.objects.get(codename="delete_user")
    except Permission.DoesNotExist:
        pass
    else:
        perm.codename = "delete_katuser"
        perm.name = "Can delete kat user"
        perm.save()
    try:
        perm = Permission.objects.get(codename="view_user")
    except Permission.DoesNotExist:
        pass
    else:
        perm.codename = "view_katuser"
        perm.name = "Can view kat user"
        perm.save()


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ("auth", "0012_alter_user_first_name_max_length"),
    ]

    operations = [
        SwitchToCustomUserModel(),
        migrations.RenameModel(
            old_name="User",
            new_name="KATUser",
        ),
        migrations.AlterModelOptions(
            name="katuser",
            options={},
        ),
        migrations.AlterModelTable(
            name="katuser",
            table=None,
        ),
        migrations.RunSQL(
            [
                "ALTER INDEX auth_user_pkey RENAME TO account_katuser_pkey",
                "ALTER INDEX auth_user_groups_pkey RENAME TO account_katuser_groups_pkey",
                "ALTER INDEX auth_user_user_permissions_pkey RENAME TO account_katuser_user_permissions_pkey",
                "ALTER SEQUENCE auth_user_id_seq RENAME TO account_katuser_id_seq",
                "ALTER SEQUENCE auth_user_groups_id_seq RENAME TO account_katuser_groups_id_seq",
                "ALTER SEQUENCE auth_user_user_permissions_id_seq RENAME TO account_katuser_user_permissions_id_seq",
            ]
        ),
        migrations.RunPython(fix_names),
        migrations.RunPython(fix_contenttypes_and_permissions),
        migrations.AlterModelManagers(
            name="katuser",
            managers=[],
        ),
        migrations.RemoveField(
            model_name="katuser",
            name="username",
        ),
        migrations.AddField(
            model_name="katuser",
            name="full_name",
            field=models.CharField(
                blank=True, max_length=150, verbose_name="full name"
            ),
        ),
        migrations.AlterField(
            model_name="katuser",
            name="email",
            field=account.models.LowercaseEmailField(
                max_length=254, unique=True, verbose_name="email"
            ),
        ),
        migrations.RunPython(set_full_name),
    ]
